---
id: code-splitting
title: Code Splitting
sidebar_label: Code Splitting
hide_title: true
description: 'RTK Query > Usage > Code Splitting: dynamic injection of endpoints'
---

&nbsp;

# Code Splitting

## Overview

By default, an RTK Query API definition normally has all of the endpoint definitions in a single file. However, in larger applications this can result in very large files that may be harder to maintain. It also means that all of the relevant code is being imported right away.

RTK Query allows dynamically injecting endpoint definitions into an existing API service object. This enables splitting up endpoints into multiple files for maintainability, as well as lazy-loading endpoint definitions and associated code to trim down initial bundle sizes. This can be very beneficial for larger applications that may have _many_ endpoints.

## Injecting Endpoints

`api.injectEndpoints` accepts a collection of endpoint definitions (same as `createApi`), as well as an optional `overrideExisting` parameter.

Calling `api.injectEndpoints` will inject the endpoints into the original API service object, modifying it immediately. It returns **the _same_ API service object reference**. If you're using TypeScript, the return value has the TS types for the new endpoints included. (Unfortunately, it cannot modify the types for the original API reference.)

A typical approach would be to have one empty central API slice definition:

```ts title="Basic setup"
// Or from '@reduxjs/toolkit/query' if not using the auto-generated hooks
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'

// initialize an empty api service that we'll inject endpoints into later as needed
export const emptySplitApi = createApi({
  baseQuery: fetchBaseQuery({ baseUrl: '/' }),
  endpoints: () => ({}),
})
```

and then inject the api endpoints in other files and export them from there - that way you will be sure to always import the endpoints in a way that they are definitely injected.

```ts title="Injecting & exporting additional endpoints"
// file: emptySplitApi.ts noEmit
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'

export const emptySplitApi = createApi({
  baseQuery: fetchBaseQuery({ baseUrl: '/' }),
  endpoints: () => ({}),
})

// file: extendedApi.ts
import { emptySplitApi } from './emptySplitApi'

// NOTE: these are the _SAME_ API reference!
const extendedApi = emptySplitApi.injectEndpoints({
  endpoints: (build) => ({
    example: build.query({
      query: () => 'test',
    }),
  }),
  overrideExisting: false,
})

export const { useExampleQuery } = extendedApi
```

:::tip
If you inject an endpoint that already exists and don't explicitly specify `overrideExisting: true`, the endpoint
will not be overridden. In development mode, you will get a warning about this if `overrideExisting` is set to `false`,
and an error will be throw if set to `'throw'`.
:::

## Enhancing Endpoints

Sometimes you may also need to modify an existing API definition, such as adding additional tag types, or providing additional configuration options to a given endpoint.

`api.enhanceEndpoints` returns an updated and enhanced version of the API slice object, containing the combined endpoint definitions.

This is primarily useful for taking an API slice object that was code-generated from an API schema file like OpenAPI, and adding additional specific hand-written configuration for cache invalidation management on top of the generated endpoint definitions.

For example, `enhanceEndpoints` can be used to modify caching behavior by changing the values of `providesTags`, `invalidatesTags`, and `keepUnusedDataFor`:

```ts
// file: api.ts noEmit
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'

export const api = createApi({
  baseQuery: fetchBaseQuery({ baseUrl: '/' }),
  endpoints: (build) => ({
    getUserByUserId: build.query({
      query() {
        return ''
      },
    }),
    patchUserByUserId: build.mutation({
      query() {
        return ''
      },
    }),
    getUsers: build.query({
      query() {
        return ''
      },
    }),
  }),
})

// file: enhanceEndpoints.ts
import { api } from './api'

const enhancedApi = api.enhanceEndpoints({
  addTagTypes: ['User'],
  endpoints: {
    getUserByUserId: {
      providesTags: ['User'],
    },
    patchUserByUserId: {
      invalidatesTags: ['User'],
    },
    // alternatively, define a function which is called with the endpoint definition as an argument
    getUsers(endpoint) {
      endpoint.providesTags = ['User']
      endpoint.keepUnusedDataFor = 120
    },
  },
})
```

## Sharing Endpoint Definitions Across Apps (Monorepos)

In a monorepo setup, you may want to define reusable endpoint definitions in a shared package that multiple apps can use. For example, you might have a `@myorg/auth` package containing authentication-related endpoints that are used by several different applications.

The challenge is that the shared package doesn't have direct access to each app's API instance. The solution is to **export a callback function** from the shared package that the consuming app can call with its own API instance.

This pattern is similar to the approach used for [organizing listener middleware callbacks](../../api/createListenerMiddleware.mdx#organizing-listeners-in-files), and avoids circular import issues since the shared package doesn't need to import the app's API.

### Exporting an Injection Callback

The recommended approach is to export a function that accepts an API instance, calls `injectEndpoints`, and returns the result:

```ts title="packages/auth/src/authEndpoints.ts"
import type { Api } from '@reduxjs/toolkit/query/react'

export interface AuthUser {
  id: string
  name: string
  email: string
}

export interface LoginRequest {
  username: string
  password: string
}

export interface LoginResponse {
  user: AuthUser
  token: string
}

// Export a callback that accepts the app's API instance
// and injects the auth-related endpoints
export const injectAuthEndpoints = <A extends Api<any, {}, any, any, any>>(
  api: A,
) => {
  return api.injectEndpoints({
    endpoints: (build) => ({
      login: build.mutation<LoginResponse, LoginRequest>({
        query: (credentials) => ({
          url: 'auth/login',
          method: 'POST',
          body: credentials,
        }),
      }),
      getMe: build.query<AuthUser, void>({
        query: () => 'auth/me',
      }),
    }),
  })
}
```

Then, in the consuming app, import the callback, call it with your API instance, and export the hooks:

```ts title="apps/my-app/src/store/authApi.ts"
import { injectAuthEndpoints } from '@myorg/auth'
import { api } from './api'

// Call the injection function with your app's API instance
const authApi = injectAuthEndpoints(api)

// Export the generated hooks for use in components
export const { useLoginMutation, useGetMeQuery } = authApi
```

Note that **hooks must be exported from the app-side file**, not from the shared package. This is because the hooks are generated based on the specific API instance, and the shared package doesn't have access to that instance until the callback is called.

### Alternative: Exporting Endpoint Definitions Directly

Instead of calling `injectEndpoints` inside the callback, you can export just the endpoint definitions and let the app spread them into its `createApi` call or `injectEndpoints` call:

```ts title="packages/auth/src/authEndpoints.ts"
import type { EndpointBuilder } from '@reduxjs/toolkit/query/react'

export interface AuthUser {
  id: string
  name: string
  email: string
}

// Export a callback that returns endpoint definitions
// Using `any` for the builder generics allows this to work with any API configuration
export const authEndpoints = (build: EndpointBuilder<any, any, any>) => ({
  login: build.mutation<LoginResponse, LoginRequest>({
    query: (credentials) => ({
      url: 'auth/login',
      method: 'POST',
      body: credentials,
    }),
  }),
  getMe: build.query<AuthUser, void>({
    query: () => 'auth/me',
  }),
})
```

```ts title="apps/my-app/src/store/api.ts"
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'
import { authEndpoints } from '@myorg/auth'

export const api = createApi({
  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
  endpoints: (build) => ({
    // Spread in the shared endpoints
    ...authEndpoints(build),
    // Add app-specific endpoints
    getAppConfig: build.query<AppConfig, void>({
      query: () => 'config',
    }),
  }),
})

export const { useLoginMutation, useGetMeQuery, useGetAppConfigQuery } = api
```

Both approaches achieve the same result. The first approach (injection callback) is more natural if you're working with an existing empty API and using `injectEndpoints` elsewhere. The second approach (endpoint definitions) works well when you want to compose all endpoints at `createApi` time.

### Handling Tag Types

If your shared endpoints need to provide or invalidate cache tags, you have a couple options:

1. **Define shared tag types in the base API**: If the tag types are known upfront, define them in the app's `createApi` call:

```ts title="apps/my-app/src/store/api.ts"
export const api = createApi({
  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
  tagTypes: ['Auth', 'User'], // Define tags that shared endpoints will use
  endpoints: () => ({}),
})
```

2. **Use `enhanceEndpoints` to add tag types**: If different shared packages need different tags, use `enhanceEndpoints` after injection:

```ts title="apps/my-app/src/store/authApi.ts"
import { injectAuthEndpoints } from '@myorg/auth'
import { api } from './api'

const injectedApi = injectAuthEndpoints(api)

// Add tag types and configure caching behavior
const authApi = injectedApi.enhanceEndpoints({
  addTagTypes: ['Auth'],
  endpoints: {
    getMe: {
      providesTags: ['Auth'],
    },
  },
})

export const { useLoginMutation, useGetMeQuery } = authApi
```

### Shared Selectors with Partial State Types

When sharing Redux slice code across apps, selectors face a similar challenge: they don't know the app's full `RootState` type. The solution is to define a minimal interface describing just the slice of state the selector needs:

```ts title="packages/auth/src/authSlice.ts"
import { createSlice } from '@reduxjs/toolkit'

export interface AuthState {
  isAuthenticated: boolean
  user: AuthUser | null
}

const initialState: AuthState = {
  isAuthenticated: false,
  user: null,
}

export const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    setUser(state, action) {
      state.user = action.payload
      state.isAuthenticated = true
    },
    logout(state) {
      state.user = null
      state.isAuthenticated = false
    },
  },
})

// Define a minimal interface for the state shape this selector expects
interface AuthRootState {
  auth: AuthState
}

// Selector works with any RootState that has `auth` at the right key
export const selectCurrentUser = (state: AuthRootState) => state.auth.user
export const selectIsAuthenticated = (state: AuthRootState) =>
  state.auth.isAuthenticated
```

This approach allows the selectors to be used in any app that mounts the auth slice at the `auth` key, regardless of what other slices exist in that app's store.
