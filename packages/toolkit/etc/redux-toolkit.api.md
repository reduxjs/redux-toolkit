## API Report File for "@reduxjs/toolkit"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
import type { Action } from 'redux'
import type { ActionCreator } from 'redux'
import type { AnyAction } from 'redux'
import type { CombinedState } from 'redux'
import { default as createNextState } from 'immer'
import { createSelector } from 'reselect'
import { current } from 'immer'
import type { Dispatch } from 'redux'
import { Draft } from 'immer'
import { freeze } from 'immer'
import { isDraft } from 'immer'
import type { Middleware } from 'redux'
import { original } from 'immer'
import { OutputParametricSelector } from 'reselect'
import { OutputSelector } from 'reselect'
import { ParametricSelector } from 'reselect'
import type { PreloadedState } from 'redux'
import type { Reducer } from 'redux'
import type { ReducersMapObject } from 'redux'
import { Selector } from 'reselect'
import type { Store } from 'redux'
import type { StoreEnhancer } from 'redux'
import { ThunkAction } from 'redux-thunk'
import { ThunkDispatch } from 'redux-thunk'
import type { ThunkMiddleware } from 'redux-thunk'

// @public
export interface ActionCreatorWithNonInferrablePayload<
  T extends string = string
> extends BaseActionCreator<unknown, T> {
  <PT extends unknown>(payload: PT): PayloadAction<PT, T>
}

// @public
export interface ActionCreatorWithOptionalPayload<P, T extends string = string>
  extends BaseActionCreator<P, T> {
  (payload?: P): PayloadAction<P, T>
}

// @public
export interface ActionCreatorWithoutPayload<T extends string = string>
  extends BaseActionCreator<undefined, T> {
  (): PayloadAction<undefined, T>
}

// @public
export interface ActionCreatorWithPayload<P, T extends string = string>
  extends BaseActionCreator<P, T> {
  (payload: P): PayloadAction<P, T>
}

// @public
export interface ActionCreatorWithPreparedPayload<
  Args extends unknown[],
  P,
  T extends string = string,
  E = never,
  M = never
> extends BaseActionCreator<P, T, M, E> {
  (...args: Args): PayloadAction<P, T, M, E>
}

// @public (undocumented)
export type ActionMatchingAllOf<
  Matchers extends [Matcher<any>, ...Matcher<any>[]]
> = UnionToIntersection<ActionMatchingAnyOf<Matchers>>

// @public (undocumented)
export type ActionMatchingAnyOf<
  Matchers extends [Matcher<any>, ...Matcher<any>[]]
> = ActionFromMatcher<Matchers[number]>

// @public
export interface ActionReducerMapBuilder<State> {
  addCase<ActionCreator extends TypedActionCreator<string>>(
    actionCreator: ActionCreator,
    reducer: CaseReducer<State, ReturnType<ActionCreator>>
  ): ActionReducerMapBuilder<State>
  addCase<Type extends string, A extends Action<Type>>(
    type: Type,
    reducer: CaseReducer<State, A>
  ): ActionReducerMapBuilder<State>
  addDefaultCase(reducer: CaseReducer<State, AnyAction>): {}
  addMatcher<A>(
    matcher: TypeGuard<A> | ((action: any) => boolean),
    reducer: CaseReducer<State, A extends AnyAction ? A : A & AnyAction>
  ): Omit<ActionReducerMapBuilder<State>, 'addCase'>
}

// @public @deprecated
export type Actions<T extends keyof any = string> = Record<T, Action>

// @public
export type AsyncThunk<
  Returned,
  ThunkArg,
  ThunkApiConfig extends AsyncThunkConfig
> = AsyncThunkActionCreator<Returned, ThunkArg, ThunkApiConfig> & {
  pending: AsyncThunkPendingActionCreator<ThunkArg, ThunkApiConfig>
  rejected: AsyncThunkRejectedActionCreator<ThunkArg, ThunkApiConfig>
  fulfilled: AsyncThunkFulfilledActionCreator<
    Returned,
    ThunkArg,
    ThunkApiConfig
  >
  typePrefix: string
}

// @public
export type AsyncThunkAction<
  Returned,
  ThunkArg,
  ThunkApiConfig extends AsyncThunkConfig
> = (
  dispatch: GetDispatch<ThunkApiConfig>,
  getState: () => GetState<ThunkApiConfig>,
  extra: GetExtra<ThunkApiConfig>
) => Promise<
  | ReturnType<AsyncThunkFulfilledActionCreator<Returned, ThunkArg>>
  | ReturnType<AsyncThunkRejectedActionCreator<ThunkArg, ThunkApiConfig>>
> & {
  abort: (reason?: string) => void
  requestId: string
  arg: ThunkArg
  unwrap: () => Promise<Returned>
}

// @public
export type AsyncThunkOptions<
  ThunkArg = void,
  ThunkApiConfig extends AsyncThunkConfig = {}
> = {
  condition?(
    arg: ThunkArg,
    api: Pick<GetThunkAPI<ThunkApiConfig>, 'getState' | 'extra'>
  ): MaybePromise<boolean | undefined>
  dispatchConditionRejection?: boolean
  serializeError?: (x: unknown) => GetSerializedErrorType<ThunkApiConfig>
  idGenerator?: (arg: ThunkArg) => string
} & IsUnknown<
  GetPendingMeta<ThunkApiConfig>,
  {
    getPendingMeta?(
      base: {
        arg: ThunkArg
        requestId: string
      },
      api: Pick<GetThunkAPI<ThunkApiConfig>, 'getState' | 'extra'>
    ): GetPendingMeta<ThunkApiConfig>
  },
  {
    getPendingMeta(
      base: {
        arg: ThunkArg
        requestId: string
      },
      api: Pick<GetThunkAPI<ThunkApiConfig>, 'getState' | 'extra'>
    ): GetPendingMeta<ThunkApiConfig>
  }
>

// @public
export type AsyncThunkPayloadCreator<
  Returned,
  ThunkArg = void,
  ThunkApiConfig extends AsyncThunkConfig = {}
> = (
  arg: ThunkArg,
  thunkAPI: GetThunkAPI<ThunkApiConfig>
) => AsyncThunkPayloadCreatorReturnValue<Returned, ThunkApiConfig>

// @public
export type AsyncThunkPayloadCreatorReturnValue<
  Returned,
  ThunkApiConfig extends AsyncThunkConfig
> = MaybePromise<
  | IsUnknown<
      GetFulfilledMeta<ThunkApiConfig>,
      Returned,
      FulfillWithMeta<Returned, GetFulfilledMeta<ThunkApiConfig>>
    >
  | RejectWithValue<
      GetRejectValue<ThunkApiConfig>,
      GetRejectedMeta<ThunkApiConfig>
    >
>

// @public
export type CaseReducer<S = any, A extends Action = AnyAction> = (
  state: Draft<S>,
  action: A
) => S | void | Draft<S>

// @public
export type CaseReducerActions<CaseReducers extends SliceCaseReducers<any>> = {
  [Type in keyof CaseReducers]: CaseReducers[Type] extends {
    prepare: any
  }
    ? ActionCreatorForCaseReducerWithPrepare<CaseReducers[Type]>
    : ActionCreatorForCaseReducer<CaseReducers[Type]>
}

// @public @deprecated
export type CaseReducers<S, AS extends Actions> = {
  [T in keyof AS]: AS[T] extends Action ? CaseReducer<S, AS[T]> : void
}

// @public
export type CaseReducerWithPrepare<State, Action extends PayloadAction> = {
  reducer: CaseReducer<State, Action>
  prepare: PrepareAction<Action['payload']>
}

// @public (undocumented)
export type Comparer<T> = (a: T, b: T) => number

// @public
export type ConfigureEnhancersCallback = (
  defaultEnhancers: readonly StoreEnhancer[]
) => StoreEnhancer[]

// @public
export function configureStore<
  S = any,
  A extends Action = AnyAction,
  M extends Middlewares<S> = [ThunkMiddlewareFor<S>]
>(options: ConfigureStoreOptions<S, A, M>): EnhancedStore<S, A, M>

// @public
export interface ConfigureStoreOptions<
  S = any,
  A extends Action = AnyAction,
  M extends Middlewares<S> = Middlewares<S>
> {
  devTools?: boolean | EnhancerOptions
  enhancers?: StoreEnhancer[] | ConfigureEnhancersCallback
  middleware?: ((getDefaultMiddleware: CurriedGetDefaultMiddleware<S>) => M) | M
  preloadedState?: PreloadedState<CombinedState<NoInfer<S>>>
  reducer: Reducer<S, A> | ReducersMapObject<S, A>
}

// @public
export function createAction<P = void, T extends string = string>(
  type: T
): PayloadActionCreator<P, T>

// @public
export function createAction<
  PA extends PrepareAction<any>,
  T extends string = string
>(
  type: T,
  prepareAction: PA
): PayloadActionCreator<ReturnType<PA>['payload'], T, PA>

// @public (undocumented)
export function createAsyncThunk<Returned, ThunkArg = void>(
  typePrefix: string,
  payloadCreator: AsyncThunkPayloadCreator<Returned, ThunkArg, {}>,
  options?: AsyncThunkOptions<ThunkArg, {}>
): AsyncThunk<Returned, ThunkArg, {}>

// @public (undocumented)
export function createAsyncThunk<
  Returned,
  ThunkArg,
  ThunkApiConfig extends AsyncThunkConfig
>(
  typePrefix: string,
  payloadCreator: AsyncThunkPayloadCreator<Returned, ThunkArg, ThunkApiConfig>,
  options?: AsyncThunkOptions<ThunkArg, ThunkApiConfig>
): AsyncThunk<Returned, ThunkArg, ThunkApiConfig>

// @public
export const createDraftSafeSelector: typeof createSelector

// @public (undocumented)
export function createEntityAdapter<T>(options?: {
  selectId?: IdSelector<T>
  sortComparer?: false | Comparer<T>
}): EntityAdapter<T>

// @public
export function createImmutableStateInvariantMiddleware(
  options?: ImmutableStateInvariantMiddlewareOptions
): Middleware

export { createNextState }

// @public
export function createReducer<S extends NotFunction<any>>(
  initialState: S | (() => S),
  builderCallback: (builder: ActionReducerMapBuilder<S>) => void
): ReducerWithInitialState<S>

// @public
export function createReducer<
  S extends NotFunction<any>,
  CR extends CaseReducers<S, any> = CaseReducers<S, any>
>(
  initialState: S | (() => S),
  actionsMap: CR,
  actionMatchers?: ActionMatcherDescriptionCollection<S>,
  defaultCaseReducer?: CaseReducer<S>
): ReducerWithInitialState<S>

export { createSelector }

// @public
export function createSerializableStateInvariantMiddleware(
  options?: SerializableStateInvariantMiddlewareOptions
): Middleware

// @public
export function createSlice<
  State,
  CaseReducers extends SliceCaseReducers<State>,
  Name extends string = string
>(
  options: CreateSliceOptions<State, CaseReducers, Name>
): Slice<State, CaseReducers, Name>

// @public
export interface CreateSliceOptions<
  State = any,
  CR extends SliceCaseReducers<State> = SliceCaseReducers<State>,
  Name extends string = string
> {
  extraReducers?:
    | CaseReducers<NoInfer<State>, any>
    | ((builder: ActionReducerMapBuilder<NoInfer<State>>) => void)
  initialState: State | (() => State)
  name: Name
  reducers: ValidateSliceCaseReducers<State, CR>
}

export { current }

// @public (undocumented)
export interface Dictionary<T> extends DictionaryNum<T> {
  // (undocumented)
  [id: string]: T | undefined
}

export { Draft }

// @public
export interface EnhancedStore<
  S = any,
  A extends Action = AnyAction,
  M extends Middlewares<S> = Middlewares<S>
> extends Store<S, A> {
  dispatch: Dispatch<A> & DispatchForMiddlewares<M>
}

// @public (undocumented)
export interface EntityAdapter<T> extends EntityStateAdapter<T> {
  // (undocumented)
  getInitialState(): EntityState<T>
  // (undocumented)
  getInitialState<S extends object>(state: S): EntityState<T> & S
  // (undocumented)
  getSelectors(): EntitySelectors<T, EntityState<T>>
  // (undocumented)
  getSelectors<V>(
    selectState: (state: V) => EntityState<T>
  ): EntitySelectors<T, V>
  // (undocumented)
  selectId: IdSelector<T>
  // (undocumented)
  sortComparer: false | Comparer<T>
}

// @public (undocumented)
export type EntityId = number | string

// @public (undocumented)
export interface EntitySelectors<T, V> {
  // (undocumented)
  selectAll: (state: V) => T[]
  // (undocumented)
  selectById: (state: V, id: EntityId) => T | undefined
  // (undocumented)
  selectEntities: (state: V) => Dictionary<T>
  // (undocumented)
  selectIds: (state: V) => EntityId[]
  // (undocumented)
  selectTotal: (state: V) => number
}

// @public (undocumented)
export interface EntityState<T> {
  // (undocumented)
  entities: Dictionary<T>
  // (undocumented)
  ids: EntityId[]
}

// @public (undocumented)
export interface EntityStateAdapter<T> {
  // (undocumented)
  addMany<S extends EntityState<T>>(
    state: PreventAny<S, T>,
    entities: readonly T[] | Record<EntityId, T>
  ): S
  // (undocumented)
  addMany<S extends EntityState<T>>(
    state: PreventAny<S, T>,
    entities: PayloadAction<readonly T[] | Record<EntityId, T>>
  ): S
  // (undocumented)
  addOne<S extends EntityState<T>>(state: PreventAny<S, T>, entity: T): S
  // (undocumented)
  addOne<S extends EntityState<T>>(
    state: PreventAny<S, T>,
    action: PayloadAction<T>
  ): S
  // (undocumented)
  removeAll<S extends EntityState<T>>(state: PreventAny<S, T>): S
  // (undocumented)
  removeMany<S extends EntityState<T>>(
    state: PreventAny<S, T>,
    keys: readonly EntityId[]
  ): S
  // (undocumented)
  removeMany<S extends EntityState<T>>(
    state: PreventAny<S, T>,
    keys: PayloadAction<readonly EntityId[]>
  ): S
  // (undocumented)
  removeOne<S extends EntityState<T>>(state: PreventAny<S, T>, key: EntityId): S
  // (undocumented)
  removeOne<S extends EntityState<T>>(
    state: PreventAny<S, T>,
    key: PayloadAction<EntityId>
  ): S
  // (undocumented)
  setAll<S extends EntityState<T>>(
    state: PreventAny<S, T>,
    entities: readonly T[] | Record<EntityId, T>
  ): S
  // (undocumented)
  setAll<S extends EntityState<T>>(
    state: PreventAny<S, T>,
    entities: PayloadAction<readonly T[] | Record<EntityId, T>>
  ): S
  // (undocumented)
  setMany<S extends EntityState<T>>(
    state: PreventAny<S, T>,
    entities: readonly T[] | Record<EntityId, T>
  ): S
  // (undocumented)
  setMany<S extends EntityState<T>>(
    state: PreventAny<S, T>,
    entities: PayloadAction<readonly T[] | Record<EntityId, T>>
  ): S
  // (undocumented)
  setOne<S extends EntityState<T>>(state: PreventAny<S, T>, entity: T): S
  // (undocumented)
  setOne<S extends EntityState<T>>(
    state: PreventAny<S, T>,
    action: PayloadAction<T>
  ): S
  // (undocumented)
  updateMany<S extends EntityState<T>>(
    state: PreventAny<S, T>,
    updates: ReadonlyArray<Update<T>>
  ): S
  // (undocumented)
  updateMany<S extends EntityState<T>>(
    state: PreventAny<S, T>,
    updates: PayloadAction<ReadonlyArray<Update<T>>>
  ): S
  // (undocumented)
  updateOne<S extends EntityState<T>>(
    state: PreventAny<S, T>,
    update: Update<T>
  ): S
  // (undocumented)
  updateOne<S extends EntityState<T>>(
    state: PreventAny<S, T>,
    update: PayloadAction<Update<T>>
  ): S
  // (undocumented)
  upsertMany<S extends EntityState<T>>(
    state: PreventAny<S, T>,
    entities: readonly T[] | Record<EntityId, T>
  ): S
  // (undocumented)
  upsertMany<S extends EntityState<T>>(
    state: PreventAny<S, T>,
    entities: PayloadAction<readonly T[] | Record<EntityId, T>>
  ): S
  // (undocumented)
  upsertOne<S extends EntityState<T>>(state: PreventAny<S, T>, entity: T): S
  // (undocumented)
  upsertOne<S extends EntityState<T>>(
    state: PreventAny<S, T>,
    entity: PayloadAction<T>
  ): S
}

// @public (undocumented)
export function findNonSerializableValue(
  value: unknown,
  path?: string,
  isSerializable?: (value: unknown) => boolean,
  getEntries?: (value: unknown) => [string, any][],
  ignoredPaths?: readonly (string | RegExp)[]
): NonSerializableValue | false

export { freeze }

// @public @deprecated
export function getDefaultMiddleware<
  S = any,
  O extends Partial<GetDefaultMiddlewareOptions> = {
    thunk: true
    immutableCheck: true
    serializableCheck: true
  }
>(options?: O): MiddlewareArray<Middleware<{}, S> | ThunkMiddlewareFor<S, O>>

// @public
export function getType<T extends string>(
  actionCreator: PayloadActionCreator<any, T>
): T

// @public (undocumented)
export type IdSelector<T> = (model: T) => EntityId

// @public
export interface ImmutableStateInvariantMiddlewareOptions {
  // (undocumented)
  ignore?: string[]
  ignoredPaths?: string[]
  isImmutable?: IsImmutableFunc
  warnAfter?: number
}

// @public
export function isAllOf<Matchers extends [Matcher<any>, ...Matcher<any>[]]>(
  ...matchers: Matchers
): (
  action: any
) => action is UnionToIntersection<ActionFromMatcher<Matchers[number]>>

// @public
export function isAnyOf<Matchers extends [Matcher<any>, ...Matcher<any>[]]>(
  ...matchers: Matchers
): (action: any) => action is ActionFromMatcher<Matchers[number]>

// @public
export function isAsyncThunkAction(): (
  action: any
) => action is UnknownAsyncThunkAction

// @public
export function isAsyncThunkAction<
  AsyncThunks extends [AnyAsyncThunk, ...AnyAsyncThunk[]]
>(
  ...asyncThunks: AsyncThunks
): (action: any) => action is ActionsFromAsyncThunk<AsyncThunks[number]>

// @public
export function isAsyncThunkAction(
  action: any
): action is UnknownAsyncThunkAction

export { isDraft }

// @public
export function isFulfilled(): (
  action: any
) => action is UnknownAsyncThunkFulfilledAction

// @public
export function isFulfilled<
  AsyncThunks extends [AnyAsyncThunk, ...AnyAsyncThunk[]]
>(
  ...asyncThunks: AsyncThunks
): (action: any) => action is FulfilledActionFromAsyncThunk<AsyncThunks[number]>

// @public
export function isFulfilled(
  action: any
): action is UnknownAsyncThunkFulfilledAction

// @public
export function isImmutableDefault(value: unknown): boolean

// @public
export function isPending(): (
  action: any
) => action is UnknownAsyncThunkPendingAction

// @public
export function isPending<
  AsyncThunks extends [AnyAsyncThunk, ...AnyAsyncThunk[]]
>(
  ...asyncThunks: AsyncThunks
): (action: any) => action is PendingActionFromAsyncThunk<AsyncThunks[number]>

// @public
export function isPending(action: any): action is UnknownAsyncThunkPendingAction

// @public
export function isPlain(val: any): boolean

// @public
export function isPlainObject(value: unknown): value is object

// @public
export function isRejected(): (
  action: any
) => action is UnknownAsyncThunkRejectedAction

// @public
export function isRejected<
  AsyncThunks extends [AnyAsyncThunk, ...AnyAsyncThunk[]]
>(
  ...asyncThunks: AsyncThunks
): (action: any) => action is RejectedActionFromAsyncThunk<AsyncThunks[number]>

// @public
export function isRejected(
  action: any
): action is UnknownAsyncThunkRejectedAction

// @public
export function isRejectedWithValue(): (
  action: any
) => action is UnknownAsyncThunkRejectedAction

// @public
export function isRejectedWithValue<
  AsyncThunks extends [AnyAsyncThunk, ...AnyAsyncThunk[]]
>(
  ...asyncThunks: AsyncThunks
): (
  action: any
) => action is RejectedWithValueActionFromAsyncThunk<AsyncThunks[number]>

// @public
export function isRejectedWithValue(
  action: any
): action is UnknownAsyncThunkRejectedAction

// @public (undocumented)
export class MiddlewareArray<
  Middlewares extends Middleware<any, any>
> extends Array<Middlewares> {
  // (undocumented)
  static get [Symbol.species](): any
  constructor(arrayLength?: number)
  constructor(...items: Middlewares[])
  // (undocumented)
  concat<AdditionalMiddlewares extends ReadonlyArray<Middleware<any, any>>>(
    items: AdditionalMiddlewares
  ): MiddlewareArray<Middlewares | AdditionalMiddlewares[number]>
  // (undocumented)
  concat<AdditionalMiddlewares extends ReadonlyArray<Middleware<any, any>>>(
    ...items: AdditionalMiddlewares
  ): MiddlewareArray<Middlewares | AdditionalMiddlewares[number]>
  // (undocumented)
  prepend<AdditionalMiddlewares extends ReadonlyArray<Middleware<any, any>>>(
    items: AdditionalMiddlewares
  ): MiddlewareArray<AdditionalMiddlewares[number] | Middlewares>
  // (undocumented)
  prepend<AdditionalMiddlewares extends ReadonlyArray<Middleware<any, any>>>(
    ...items: AdditionalMiddlewares
  ): MiddlewareArray<AdditionalMiddlewares[number] | Middlewares>
}

// @public
export const miniSerializeError: (value: any) => SerializedError

// @public (undocumented)
export let nanoid: (size?: number) => string

export { original }

export { OutputParametricSelector }

export { OutputSelector }

export { ParametricSelector }

// @public
export type PayloadAction<
  P = void,
  T extends string = string,
  M = never,
  E = never
> = {
  payload: P
  type: T
} & ([M] extends [never]
  ? {}
  : {
      meta: M
    }) &
  ([E] extends [never]
    ? {}
    : {
        error: E
      })

// @public
export type PayloadActionCreator<
  P = void,
  T extends string = string,
  PA extends PrepareAction<P> | void = void
> = IfPrepareActionMethodProvided<
  PA,
  _ActionCreatorWithPreparedPayload<PA, T>,
  IsAny<
    P,
    ActionCreatorWithPayload<any, T>,
    IsUnknownOrNonInferrable<
      P,
      ActionCreatorWithNonInferrablePayload<T>,
      IfVoid<
        P,
        ActionCreatorWithoutPayload<T>,
        IfMaybeUndefined<
          P,
          ActionCreatorWithOptionalPayload<P, T>,
          ActionCreatorWithPayload<P, T>
        >
      >
    >
  >
>

// @public
export type PrepareAction<P> =
  | ((...args: any[]) => {
      payload: P
    })
  | ((...args: any[]) => {
      payload: P
      meta: any
    })
  | ((...args: any[]) => {
      payload: P
      error: any
    })
  | ((...args: any[]) => {
      payload: P
      meta: any
      error: any
    })

export { Selector }

// @public
export interface SerializableStateInvariantMiddlewareOptions {
  getEntries?: (value: any) => [string, any][]
  ignoredActionPaths?: (string | RegExp)[]
  ignoredActions?: string[]
  ignoredPaths?: (string | RegExp)[]
  ignoreState?: boolean
  isSerializable?: (value: any) => boolean
  warnAfter?: number
}

// @public (undocumented)
export interface SerializedError {
  // (undocumented)
  code?: string
  // (undocumented)
  message?: string
  // (undocumented)
  name?: string
  // (undocumented)
  stack?: string
}

// @public
export interface Slice<
  State = any,
  CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,
  Name extends string = string
> {
  actions: CaseReducerActions<CaseReducers>
  caseReducers: SliceDefinedCaseReducers<CaseReducers>
  getInitialState: () => State
  name: Name
  reducer: Reducer<State>
}

// @public @deprecated
export type SliceActionCreator<P> = PayloadActionCreator<P>

// @public
export type SliceCaseReducers<State> = {
  [K: string]:
    | CaseReducer<State, PayloadAction<any>>
    | CaseReducerWithPrepare<State, PayloadAction<any, string, any, any>>
}

export { ThunkAction }

export { ThunkDispatch }

// @public (undocumented)
export function unwrapResult<R extends UnwrappableAction>(
  action: R
): UnwrappedActionPayload<R>

// @public (undocumented)
export type Update<T> = {
  id: EntityId
  changes: Partial<T>
}

// @public
export type ValidateSliceCaseReducers<
  S,
  ACR extends SliceCaseReducers<S>
> = ACR &
  {
    [T in keyof ACR]: ACR[T] extends {
      reducer(s: S, action?: infer A): any
    }
      ? {
          prepare(...a: never[]): Omit<A, 'type'>
        }
      : {}
  }

export * from 'redux'

// (No @packageDocumentation comment for this package)
```
